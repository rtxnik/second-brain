# 32.01.15 Stateful и Stateless

Stateful и Stateless — это фундаментальные концепции проектирования [[32.01.07 Container|контейнерных]] приложений. **Stateless контейнеры не сохраняют данные между перезапусками, что обеспечивает простоту масштабирования, а Stateful контейнеры используют постоянное хранилище для сохранения состояния**.

Понимание различий критично для правильного проектирования контейнерных архитектур и выбора стратегий хранения данных.

## Stateless контейнеры

Stateless (без состояния) контейнеры не сохраняют никаких данных между перезапусками и полностью восстанавливают свое состояние из внешних источников.

### Характеристики Stateless

**Эфемерность** — все данные внутри контейнера временные
**Неизменяемость** — контейнер не изменяется во время работы
**Масштабируемость** — легко создавать множественные копии
**Отказоустойчивость** — быстрое восстановление при сбоях
**Идемпотентность** — одинаковое поведение при каждом запуске

### Примеры Stateless

**API сервисы:**

```yaml
services:
  api-server:
    image: myapp/api:latest
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/mydb
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
```

**Microservices:**

```yaml
services:
  user-service:
    image: myapp/user-service:v1.2.0
    environment:
      - DB_HOST=mysql
      - CACHE_HOST=redis
    deploy:
      replicas: 3
```

## Stateful контейнеры

Stateful (с состоянием) контейнеры сохраняют важные данные, которые должны пережить перезапуск контейнера.

### Характеристики Stateful

**Постоянство данных** — сохранение данных между перезапусками
**Уникальность** — каждый экземпляр имеет собственное состояние
**Сложность масштабирования** — требует координации состояния
**Долговременность** — предназначены для длительной работы
**Зависимость от хранилища** — требуют постоянные тома

### Примеры Stateful

**Базы данных:**

```yaml
version: '3.8'
services:
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
    driver: local
```

**Monitoring системы:**

```yaml
services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'

volumes:
  prometheus_data:
```

## Сравнение

| Критерий | Stateless | Stateful |
|----------|-----------|----------|
| **Масштабируемость** | Высокая | Ограниченная |
| **Простота развертывания** | Высокая | Средняя |
| **Отказоустойчивость** | Высокая | Требует планирования |
| **Backup сложность** | Низкая | Высокая |
| **Производительность** | Высокая | Зависит от I/O |

## Лучшие практики

### Для Stateless контейнеров

- Использовать immutable образы
- Выносить конфигурацию в переменные окружения
- Минимизировать размер образов
- Избегать записи в контейнер
- Делать приложения идемпотентными

### Для Stateful контейнеров

- Использовать именованные [[32.01.10 Volumes|volumes]]
- Планировать стратегии резервного копирования
- Мониторить использование дискового пространства
- Тестировать процедуры восстановления
- Использовать init контейнеры для инициализации

Правильный выбор между Stateful и Stateless подходами зависит от требований приложения к сохранности данных, масштабируемости и архитектурных ограничений [[36.02 Микросервисы|микросервисной архитектуры]].

---

Дата создания: 2025-12-01

Ссылки:

[[32.01.00 Docker]] 
[[32.01.07 Container]] 
[[32.01.03 Архитектура]] 
[[36.02 Микросервисы]]
